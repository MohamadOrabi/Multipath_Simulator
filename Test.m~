%% Decimate vs Resample
[CAcode19, code19] = generate_PRN(3,6);     %for PRN 19

samplesPerCode = floor(fs/chip_rate*1023);
samplesPerCode_hi = floor(fs_hi/chip_rate*1023);

chip_rate = 1.023e6;

fs = 2.5e6;
fs_hi = 500e6;
f_ratio = fs_hi/fs;

code19_hi = resample_PRN(code19,samplesPerCode_hi,chip_rate,fs_hi,0);
code19_1 = resample_PRN(code19,samplesPerCode,chip_rate,fs,0);

shift_lo = 500;
shift_hi = round(shift_lo*f_ratio);
shift = shift_lo*chip_rate/fs;

code19_d1 = circshift(code19_hi, shift_hi);
code19_d1 = round(decimate(code19_d1, f_ratio));

code19_d2 = resample_PRN1(code19,samplesPerCode,chip_rate,fs,shift);
code19_d3 = resample_PRN1(code19,samplesPerCode,chip_rate,fs,1*0.5);


figure;
hold on;
%stairs(code19_d1)
stairs(code19_d2)
stairs(code19_d3)
ylim([-1.5,1.5])

figure;
plot(Corr(code19_d2,code19_d3)/length(code19_d2))


%stairs(circshift(code19_1,round(500*fs/chip_rate)))

legend('decimation','resampling','true')

%Does not work .. do not trust

%% Testing the fd and pseudorange
load('fDmat.mat')   % In Hz
load('pseudoranges.mat')    % In meters

sat = 9;    %Do not change now!

% Interpolating fD and pseudorange
pseudorange(sat,:) = interpolatevec(pseudoranges(sat,:));
fDs = interpolatevec(fDmat(sat,:));
c = 299792458;


calculated_pr = cumsum(-fDs./1575.42e6*c)*1e-3 + pseudorange(sat,1);

figure; 
hold on;
plot(pseudorange(sat,:));
plot(calculated_pr);
%legend('Actual Pseudorange', 'Calculated Using fD')

 %% MEDLL
    Residual = R;
    
    %Estimating and Removing Multipath Components
    for iterations = 1:2
        
        tau_hat1 = find(abs(real(Residual)) == abs(max(real(Residual))));
        a_hat1 = real(Residual(tau_hat1));
        R_estimate1 = a_hat1*circshift(R_reference,tau_hat1-1);
        
        R_m = Residual - R_estimate1;
        
        tau_hat2 = find(abs(real(R_m)) == abs(max(real(R_m))));
        a_hat2 = real(R_m(tau_hat2));
        R_estimate2 = a_hat2*circshift(R_reference,tau_hat2-1);
        
        Residual = Residual - R_estimate2;
        
%         figure;
%         hold on;
%         plot(real(Residual))
%         plot(real(R_noiseless));
%         plot(real(R_Actual))
%         
%         legend('Residual', 'Original', 'Actual')
%         xlim([tau_hat1-5,tau_hat1+5])

    end
    
    %Running DLL on the residual
    B_DLL = 1;
    
    delta_shift_DLL = round(fs/chip_rate/2);
%     prompt_PRN = circshift(code19,round(code_shift_hat_DLL(n)) - 1);
%     early_PRN = circshift(code19, round(code_shift_hat_DLL(n)) - delta_shift_DLL - 1);
%     late_PRN = circshift(code19, round(code_shift_hat_DLL(n)) + delta_shift_DLL - 1);
    
%     c_prompt = sum(prompt_PRN.*y_lo.*exp(1i*thetashat))./length(y_lo);
%     c_early = sum(early_PRN.*y_lo.*exp(1i*thetashat))./length(y_lo);
%     c_late = sum(late_PRN.*y_lo.*exp(1i*thetashat))./length(y_lo);

    c_prompt = real(Residual(round(code_shift_hat_MEDLL(n)) - 1));
    c_early = real(Residual(round(code_shift_hat_MEDLL(n)) - delta_shift_DLL - 1));
    c_late = real(Residual(round(code_shift_hat_MEDLL(n)) + delta_shift_DLL - 1));
    
    L_t = (real(c_prompt)*(real(c_early) - real(c_late)) + imag(c_prompt)*(imag(c_early) - imag(c_late)));
    e_t = B_DLL*C*L_t;
    shift_MEDLL_samples(n) = -e_t*fs;
    code_shift_hat_MEDLL(n+1) = round(code_shift_hat_MEDLL(n)) + shift_MEDLL_samples(n);
    
    MEDLLError(n) = ShiftsData(n) - code_shift_hat_MEDLL(n);
    
%     figure; plot(real(Residual))
%% Generate Error vs Delay figure

clc
%close all
clear all

%% Initialization

net = importKerasNetwork('modelRegression_10mhz.h5') %Imports the Keras network
%load('means.mat')  %Used for scaling inputs to NN
%load('stds.mat')
load('fDmat.mat')   % In Hz
%load('sat_poss.mat')
load('pseudoranges.mat')    % In meters
load('Elevations.mat')

sat = 9;    %Do not change now!

% Interpolating fD and pseudorange
pseudorange(sat,:) = interpolatevec(pseudoranges(sat,:));
fDs = interpolatevec(fDmat(sat,:));
El = interpolatevec(Elevations(sat,:))*180/pi;

%fDs = fDmat(6,:);
%fDs = fDmat(sat,:);

%Constants
c = 299792458;
chip_rate = 1.023e6;   %In Hz
fs = 10e6;             %In Hz
fs_hi = 500e6;
f_ratio = fs_hi/fs;
fD = 0;             % In Hz
shift_Tc = 0.5;    %max shift, in chips
CNR_dB = 35;        % in dB-Hz
runs = 500;    % # code_lengths to process
n_multipath = 7; % Number of Multipath Components

%Flags ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
plotFlag = false;   %Set to plot.. plotting is currently very slow
NNFlag = true;  %Set to use NNDLL
NarrowCorrelatorFlag = true;    %Set to use narrow correlator
EstimateDoppler = false; %Set to use PLL to estimate doppler frequency
SaveRFlag = true;
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
delta_shift_codes = 2;  %Delta Codes used as input to DLL
delta_shift_samples = round(delta_shift_codes*fs/chip_rate);

samplesPerCode = floor(fs/chip_rate*1023);
samplesPerCode_hi = floor(fs_hi/chip_rate*1023);

t = (0:samplesPerCode-1)/fs;
t_plot = t*fs;

t_hi = (0:samplesPerCode_hi-1)/fs_hi;
%t_p = (1:2*delta_shift)/fs - delta_shift/fs;


%Initialization
[CAcode19, code19] = generate_PRN(3,6);     %for PRN 19

%Resampling the PRNs
code19_hi = resample_PRN(code19,samplesPerCode_hi,chip_rate,fs_hi,0);
code19 = resample_PRN(code19,samplesPerCode,chip_rate,fs,0);

%Getting R_reference (Needed for MEDLL)
R_reference = Corr(code19,code19)/length(code19);

%Initializing training data matrices
ShiftsData = zeros(runs,1); %Errros from the center of the MDLL
SamplesData = zeros(runs,2*delta_shift_samples);
Data = zeros(runs,size(ShiftsData,2) + size(SamplesData,2));

%Initialize state space representation of PLL
if EstimateDoppler
    B_PLL = 50;
    [AA BB CC DD] = PLL_getss(B_PLL,fs);
    fDhat = fDs(1,1)
    x = [2*pi*fDhat/CC];
    phasehat = 0;
end

sigma_noise = sqrt(0.0005/(10.^(CNR_dB/10)))*samplesPerCode;
Tc = 1/chip_rate;
C = Tc/2/(1 - 2*(sigma_noise/samplesPerCode)^2);

%Initialize the Estimated variables
shift_center_hi = 0; %Estimated Shift
shift_center_lo = shift_center_hi/f_ratio;
codeshift.DLL = zeros(runs+1,1);
codeshift.NN = zeros(runs+1,1);
codeshift.Narrow_DLL = zeros(runs+1,1);

codeshift.DLL(1) = round(shift_center_hi + mod(pseudorange(sat,1),300e3)/c*fs); % Initial Value 
codeshift.NN(1) = round(shift_center_hi + mod(pseudorange(sat,1),300e3)/c*fs); % Initial Value 
codeshift.Narrow_DLL(1) = round(shift_center_hi + mod(pseudorange(sat,1),300e3)/c*fs); % Initial Value 

if (plotFlag)
    figure;
end

phase = 0;
for n = 1:runs
    %% Run Initialization
    
%     if (n<round(runs/3))
%         n_multipath = 0;
%     elseif (n<round(2*runs/3))
%         n_multipath = 0;
%     else
%         n_multipath = 0;
%     end
    
    clc;
    n/runs*100
    
    %Calculate codeshift.Actual from pseudorange(n)
    codeshift.Actual(n) = mod(pseudorange(sat,n),300e3)/c*fs_hi;   %This might cause a problem
    
    fD = fDs(n);
    
    noise1 = sigma_noise*randn(1,samplesPerCode);
    noise2 = sigma_noise*randn(1,samplesPerCode);
    noise = 1*noise1 + 1*1i*noise2;
    
    %shift = shift_Tc/chip_rate*fs*(rand-0.5);
    shift = mod(codeshift.Actual(n)-1,samplesPerCode_hi)+1;
    %shift = 1868*f_ratio;
    ShiftsData(n) = shift/f_ratio;
    
    %Shifting PRNs
    code19_d = circshift(code19_hi,round(shift)+shift_center_lo);
    code19_Multipath = 0;
    
    %Generate Multipath Signals
    %[gamma,varsigma] = getGammaParams(El(n));
    for ii = 1:n_multipath
        multipath_shift_samples = /c*fs_hi; %2.56,65.12
        theta =pi/sqrt(3)*randn;
        %Linear Model for Attenuation
        %a = -0.0032;b = -12.3;  
        a = -0.0039 + (0.0039-0.0025)*rand();   % a = (-0.0039,-0.0025)
        b = -12.7 + (12.7-11.9)*rand();
        Att_db = a*(multipath_shift_samples)/fs_hi*1e3 + b;
        
        A_M = 1*10^(Att_db/20);
        code19_Multipath = code19_Multipath + A_M*exp(1i*theta)*circshift(code19_hi,round(shift + multipath_shift_samples)+shift_center_hi);
    end
    
    thetas = 2*pi*fD*t_hi + phase;
    phase = phase + 2*pi*fD*(t_hi(end) + 1/fs_hi);
    %thetas_lo = decimate(thetas,f_ratio);
    thetas_lo = 2*pi*fD*t + phase;
    phase_lo = phase + 2*pi*fD*(t(end) + 1/fs);
    
    if(EstimateDoppler)
        thetashat = 2*pi*fDhat*t + phasehat;
        phasehat = phasehat + 2*pi*fDhat*(t(end) + 1/fs);
    else
        thetas = 0;
        thetas_lo = 0;
        thetashat = thetas_lo;
    end

    y = code19_d + code19_Multipath;% + noise;% + code25_d + code5_d;
    A = 1;
    %y = y.*A.^0.5.*exp(-1i*thetas);
    
    %Resampling to low fs
    y_lo_noiseless = decimate(y,f_ratio);
    y_lo = y_lo_noiseless + noise;

    y_lo = y_lo.*A.^0.5.*exp(-1i*thetas_lo);
    y_lo_noiseless = y_lo_noiseless.*A.^0.5.*exp(-1i*thetas_lo);

    code19_d_lo = round(decimate(code19_d,f_ratio));

    R = Corr(y_lo.*exp(1i*thetashat),code19)./length(y_lo);
    R_noiseless = Corr(y_lo_noiseless.*exp(1i*thetashat),code19)./length(y_lo);
    R_Actual = Corr((code19_d_lo).*exp(-1i*(thetas_lo-thetashat)),code19)./length(y_lo);
    
    if (SaveRFlag)
       Rs(n,:) = real(R);
    end
    
    %Calculating the SamplesData
    if (~NNFlag)
        SamplesData(n,:) = R(round(codeshift.DLL(n))-delta_shift_samples+1:round(codeshift.DLL(n))+delta_shift_samples);
        SamplesData_noiseless(n,:) = R_noiseless(round(codeshift.DLL(n))-delta_shift_samples+1:round(codeshift.DLL(n))+delta_shift_samples);
    else
        SamplesData(n,:) = R(round(codeshift.NN(n))-delta_shift_samples+1:round(codeshift.NN(n))+delta_shift_samples);
        SamplesData_noiseless(n,:) = R_noiseless(round(codeshift.NN(n))-delta_shift_samples+1:round(codeshift.NN(n))+delta_shift_samples);     
    end

    if (n_multipath > 0)
        code19_Multipath_lo = decimate(code19_Multipath,f_ratio);
        R_M = Corr((code19_Multipath_lo).*exp(-1i*(thetas_lo-thetashat)),code19)./length(y_lo);
    else
        R_M = zeros(size(R,1),size(R,2));
    end
    
    %% DLL
    B_DLL = 1;
    
    delta_shift_DLL = round(fs/chip_rate/2);
    prompt_PRN = circshift(code19,round(codeshift.DLL(n)) - 1);
    early_PRN = circshift(code19, round(codeshift.DLL(n)) - delta_shift_DLL - 1);
    late_PRN = circshift(code19, round(codeshift.DLL(n)) + delta_shift_DLL - 1);
    
    c_prompt = sum(prompt_PRN.*y_lo.*exp(1i*thetashat))./length(y_lo);
    c_early = sum(early_PRN.*y_lo.*exp(1i*thetashat))./length(y_lo);
    c_late = sum(late_PRN.*y_lo.*exp(1i*thetashat))./length(y_lo);
    
    L_t = (real(c_prompt)*(real(c_early) - real(c_late)) + imag(c_prompt)*(imag(c_early) - imag(c_late)));
    e_t = B_DLL*C*L_t;
    shift_DLL_samples(n) = -e_t*fs;
    codeshift.DLL(n+1) = round(codeshift.DLL(n)) + shift_DLL_samples(n);
    
    DLLError(n) = ShiftsData(n) - codeshift.DLL(n);
    %% Narrow Correlator
    if (NarrowCorrelatorFlag)
        B_DLL_N = 1;

        delta_shift_DLL_narrow = 1;
        prompt_PRN = circshift(code19,round(codeshift.Narrow_DLL(n)) - 1);
        early_PRN = circshift(code19, round(codeshift.Narrow_DLL(n)) - delta_shift_DLL_narrow - 1);
        late_PRN = circshift(code19, round(codeshift.Narrow_DLL(n)) + delta_shift_DLL_narrow - 1);

        c_prompt_narrow = sum(prompt_PRN.*y_lo.*exp(1i*thetashat))./length(y_lo);
        c_early_narrow = sum(early_PRN.*y_lo.*exp(1i*thetashat))./length(y_lo);
        c_late_narrow = sum(late_PRN.*y_lo.*exp(1i*thetashat))./length(y_lo);

        L_t = (real(c_prompt_narrow)*(real(c_early_narrow) - real(c_late_narrow)) + imag(c_prompt_narrow)*(imag(c_early_narrow) - imag(c_late_narrow)));
        e_t = B_DLL_N*C*L_t;
        shift_DLL_samples(n) = -e_t*fs;
        codeshift.Narrow_DLL(n+1) = round(codeshift.Narrow_DLL(n)) + shift_DLL_samples(n);

        Narrow_DLLError(n) = ShiftsData(n) - codeshift.Narrow_DLL(n);   
    end
    %% PLL
    if EstimateDoppler
        u(n) = -atan(imag(c_prompt)./real(c_prompt));
        %u(t) = asin(imag(p(t)).*real(p(t)))/2;
        x = AA*x + BB*u(n);
        o(n) = CC*x + DD*u(n);
        o(n) = o(n)/2/pi;
        fDhat = o(n);
    end 
    %% Prediction
    if (NNFlag)
        %NNShift(n) = (PredictShift_2p5(real(SamplesData(n,:))));
        NNShift(n) = double(predict(net,real(SamplesData(n,:))));
        codeshift.NN(n+1) = round(codeshift.NN(n)) + NNShift(n);
        %codeshift.Actual_hat = codeshift.Actual_hat + round(NNShift(n));
        %SamplesData_scaled = (SamplesData(n,:) - means)./stds;
        NNError(n) = ShiftsData(n) - codeshift.NN(n);
        %prompt_PRN = circshift(code19,shift_center + round(NNError(n)));
        %_promptNN = sum(prompt_PRN.*y.*exp(1i*thetashat))./length(code19_d);
        %I_DataNN(n) = c_promptNN;

    end
%%

%% Caculate RMSE
if (NNFlag)
    NN_RMSE = norm(NNError)/sqrt(runs)/fs*c
end
if (NarrowCorrelatorFlag)
    Narrow_DLL_RMSE = norm(Narrow_DLLError)/sqrt(runs)/fs*c
end

% code_shift_py = csvread('code_shifts.csv');
% ConvError = ShiftsData - code_shift_py(1:n);
% Conv_RMSE = norm(ConvError)/sqrt(runs)/fs*c

DLL_RMSE = norm(DLLError)/sqrt(runs)/fs*c

Data = [real(SamplesData),ShiftsData];
csvwrite('Data.csv',Data);
if (SaveRFlag)
   csvwrite('Rs.csv',Rs); 
end
%% Plot Pseudorange
figure;
title('Code Shift')
hold on
plot(codeshift.DLL(2:n+1));
if (NarrowCorrelatorFlag)
    plot(codeshift.Narrow_DLL(2:n+1));
end
if(NNFlag)
    plot(codeshift.NN(2:n+1));
end
plot(ShiftsData(1:n));

% code_shift_py = csvread('code_shifts.csv');
% plot(code_shift_py(2:n+1))

xline(round(runs/3));
xline(round(runs*2/3));

legend('Estimated Shift DLL','Estimated Shift Narrow Correlator', 'Estimated Shift NN', 'True Shift')




